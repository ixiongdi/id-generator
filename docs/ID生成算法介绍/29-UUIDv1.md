# UUIDv1 生成算法

## 一、算法概述
UUIDv1（Universally Unique Identifier Version 1）是UUID规范中的第一个版本，基于时间戳和节点标识符（通常为MAC地址）生成。其核心设计目标是通过结合时间信息和硬件标识，提供全局唯一且具有时序性的标识符，广泛应用于需要追踪创建时间或设备来源的场景。

## 二、核心特性
- **时间相关性**：包含60位时间戳（精确到100纳秒），可直接解析出ID生成时间
- **节点标识**：包含48位节点ID（默认使用网卡MAC地址），标识生成设备
- **时钟序列**：14位时钟序列防止时钟回拨或系统重启导致的ID冲突
- **全局唯一**：通过时间戳、时钟序列和节点ID的组合，理论上冲突概率极低
- **标准兼容**：完全符合RFC 4122规范，支持跨语言/系统解析

## 三、数据结构（128位）
UUIDv1采用固定128位（16字节）二进制结构，具体字段分配如下：

| 字段           | 长度  | 描述                                                                 |
|----------------|-------|----------------------------------------------------------------------|
| 时间戳         | 60位  | 自1582-10-15 00:00:00Z以来的100纳秒间隔数（覆盖至约5236年）           |
| 版本号（v1）   | 4位   | 固定为0001（二进制），标识UUID版本                                   |
| 时钟序列       | 14位  | 防止时钟回拨的递增序列（初始随机，时钟回拨时递增）                   |
| 变体标识       | 2位   | 固定为10（二进制），表示遵循RFC 4122规范                             |
| 节点ID         | 48位  | 设备物理地址（MAC地址），若不可获取则使用随机数                       |

### 字符串格式
二进制数据按网络字节序转换为32字符十六进制字符串，格式为：`8-4-4-4-12`，示例：
`123e4567-e89b-12d3-a456-426614174000`（其中`12d3`为版本号字段，对应v1）

## 四、生成流程
1. **获取时间戳**：计算当前时间与1582-10-15 00:00:00Z的100纳秒间隔数
2. **处理时钟回拨**：若当前时间小于上次生成时间，递增时钟序列
3. **获取节点ID**：读取本地网卡MAC地址（优先非虚拟网卡），若失败则生成随机48位数
4. **组装二进制**：按字段顺序组合时间戳、版本号、时钟序列、变体、节点ID
5. **编码字符串**：转换为标准8-4-4-4-12格式的十六进制字符串

## 五、与其他UUID版本对比
| 特性         | UUIDv1                | UUIDv4                | UUIDv7                |
|--------------|-----------------------|-----------------------|-----------------------|
| 生成依据     | 时间+MAC地址          | 随机数                | 时间+随机数           |
| 时序性       | 是（基于时间戳）      | 否                    | 是（基于时间戳）       |
| 节点信息     | 包含（MAC地址）       | 无                    | 无                    |
| 隐私风险     | 高（暴露MAC地址）      | 低                    | 低                    |
| 冲突概率     | 极低（依赖时间精度）   | 极低（2^-122）         | 极低（2^-122）         |
| 典型用途     | 设备追踪、日志溯源    | 通用唯一标识          | 时序敏感场景          |

## 六、使用注意事项
1. **隐私保护**：直接使用MAC地址可能暴露设备信息，建议替换为随机节点ID（需明确文档说明）
2. **时钟同步**：依赖系统时间精度（需<100纳秒），需部署高精度时钟服务（如NTP）
3. **时钟回拨**：系统时间调整（如夏令时、手动修改）可能导致时钟序列快速耗尽，需监控并报警
4. **MAC地址获取**：部分环境（如容器、虚拟机）无法获取物理MAC地址，需配置替代方案
5. **存储优化**：字符串格式（36字符）存储效率低，建议存储二进制形式（16字节）
6. **版本标识**：解析时需验证版本号（第13位应为'1'），避免与其他版本混淆

## 七、示例代码（Python）
```python
import uuid
from datetime import datetime

# 生成标准UUIDv1（自动获取MAC地址）
id_v1 = uuid.uuid1()
print("Standard UUIDv1:", id_v1)

# 自定义节点ID（替换MAC地址为随机数）
custom_node = 0x123456789abc  # 48位随机数
id_custom = uuid.uuid1(node=custom_node)
print("Custom Node UUIDv1:", id_custom)

# 解析时间戳（转换为Python datetime）
# UUIDv1时间戳为100纳秒间隔数，需转换为秒级时间戳
timestamp = id_v1.time / 10000000.0 + datetime(1582, 10, 15).timestamp()
print("Generated Time:", datetime.fromtimestamp(timestamp))

# 处理时钟回拨模拟（实际需监控系统时间）
last_timestamp = 0
current_timestamp = uuid.getnode()  # 示例伪代码，实际需记录上次时间
if current_timestamp < last_timestamp:
    # 递增时钟序列（Python uuid模块自动处理）
    print("Clock moved backwards, incrementing sequence...")
```

## 八、总结
UUIDv1通过结合时间戳和节点标识，提供了具有时序性和设备溯源能力的唯一标识符。适用于需要追踪ID生成时间或设备来源的场景（如物联网设备日志、分布式系统追踪）。使用时需注意隐私保护和时钟同步问题，必要时可替换节点ID为随机值以平衡功能性与安全性。