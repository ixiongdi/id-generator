# LexicalUUID 生成算法介绍

## 1. 概述
LexicalUUID 是一种**支持字典序排序的UUID扩展方案**，通过调整UUID的字段顺序，使其字符串表示可以直接按字典序排序，解决了标准UUID（如UUIDv4）因随机字段导致的无序问题。适用于需要按ID生成时间或逻辑顺序存储/查询的场景（如数据库索引、日志排序）。

## 2. 核心设计
LexicalUUID 保持了UUID的128位固定长度，通过重新排列标准UUID的字段顺序实现字典序可排序性。其核心改进点在于：

### 字段重排策略
标准UUID的规范格式为 `8-4-4-4-12` 十六进制字符串（如 `123e4567-e89b-12d3-a456-426614174000`），其中时间戳字段（若有）位于非前缀位置。LexicalUUID 将时间相关字段或自定义顺序字段调整到字符串的最前面，例如：

- **时间优先型**：将时间戳字段（如UUIDv1的60位时间戳）前置，后续为时钟序列、节点ID等
- **自定义顺序型**：根据业务需求将关键排序字段（如租户ID、业务类型）调整到前缀位置

### 编码一致性
保持与标准UUID相同的十六进制编码（32字符+4短横线），确保与现有UUID解析工具兼容，同时支持直接字符串比较排序。

## 3. 核心特性
| 特性                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| 字典序可排序        | 字符串表示可直接按ASCII顺序比较（如 `lex-123` < `lex-456`）          |
| UUID兼容性          | 保持128位二进制格式和标准字符串编码，可通过现有库解析为UUID对象      |
| 灵活字段排序        | 支持根据业务需求调整字段顺序（时间、租户、业务类型等）               |
| 全局唯一性          | 继承UUID的122位随机熵（或时间+节点唯一性），保证分布式环境下的唯一性  |

## 4. 与标准UUID对比
| 特性                | LexicalUUID             | 标准UUID（如v4）         |
|---------------------|-------------------------|--------------------------|
| 字符串排序能力      | ✅ 直接字典序排序        | ❌ 需解析后排序           |
| 字段顺序灵活性      | ✅ 可自定义调整          | ❌ 固定字段顺序           |
| 解析兼容性          | ✅ 完全兼容UUID标准      | ✅ 原生支持               |
| 典型适用场景        | 数据库索引、日志排序    | 无排序需求的唯一标识      |

## 5. 实现建议
- **字段顺序设计**：根据业务排序需求选择前置字段（如时间戳优先用于按生成时间排序，租户ID优先用于多租户隔离排序）
- **生成工具**：可基于现有UUID库扩展，通过重排字段顺序实现（如Java的`java.util.UUID`配合自定义生成逻辑）
- **存储优化**：字符串形式可直接作为数据库有序索引（如MySQL的`VARCHAR`类型），二进制形式存储更节省空间（16字节）