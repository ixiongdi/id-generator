# OrderedUUID 生成算法介绍

## 1. 概述
OrderedUUID 是一种**支持自然排序的UUID扩展方案**，通过调整标准UUID的字段顺序，使其字符串表示可直接按字典序排序。主要解决传统UUID（如UUIDv4）因随机字段导致的无序问题，适用于需要按生成时间或逻辑顺序存储/查询ID的场景（如数据库索引、日志排序）。

## 2. 核心设计
OrderedUUID 保持了UUID的128位固定长度和标准格式（32字符十六进制+4短横线），核心改进在于**时间字段前置**的排列策略：

### 字段重排规则
标准UUID的规范格式为 `8-4-4-4-12`（如 `f47ac10b-58cc-4372-a567-0e02b2c3d479`），其中时间相关字段（如UUIDv1的时间戳）位于非前缀位置。OrderedUUID 将时间戳字段（或自定义排序字段）调整到字符串最前端，典型排列方式包括：

- **时间优先型**：将60位时间戳（来自UUIDv1）前置，后续为时钟序列、节点ID等
- **业务优先型**：根据业务需求将租户ID、业务类型等关键字段调整到前缀位置

### 兼容性设计
完全兼容标准UUID解析协议（可通过`UUID.fromString()`解析为Java UUID对象），同时支持直接字符串比较排序，实现“写入即有序”。

## 3. 核心特性
| 特性                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| 自然可排序性        | 字符串表示可直接按ASCII字典序排序（如 `ord-20240101` < `ord-20240102`） |
| UUID原生兼容        | 保持128位二进制格式和标准字符串编码，无缝对接现有UUID生态工具链        |
| 灵活字段编排        | 支持根据业务需求调整字段顺序（时间、租户、业务类型等）                  |
| 全局唯一性          | 继承UUID的唯一性保证（如UUIDv1的时间+节点唯一性，或UUIDv4的随机熵）    |

## 4. 与标准UUID对比
| 特性                | OrderedUUID             | 标准UUID（如v4）         |
|---------------------|-------------------------|--------------------------|
| 字符串排序能力      | ✅ 直接字典序排序        | ❌ 需解析后排序           |
| 字段顺序灵活性      | ✅ 可自定义调整          | ❌ 固定字段顺序           |
| 解析兼容性          | ✅ 完全兼容UUID标准      | ✅ 原生支持               |
| 典型适用场景        | 数据库索引、日志排序    | 无排序需求的唯一标识      |
| 时间信息隐含性      | ✅ 时间字段前置易解析    | ❌ 时间字段（如v1）位置靠后 |

## 5. 实现建议
- **字段顺序选择**：根据业务排序需求选择前置字段（如时间戳优先用于时间序列场景，租户ID优先用于多租户隔离场景）
- **生成工具**：可基于现有UUID库扩展实现（如Java通过`UUID`类重排字段顺序）
- **存储优化**：字符串形式可直接作为数据库有序索引（推荐`VARCHAR(36)`），二进制形式存储更节省空间（16字节）
- **性能注意**：避免在高并发场景中频繁生成（时间戳获取可能成为瓶颈），建议缓存预生成ID