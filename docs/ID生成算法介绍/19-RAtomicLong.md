# RAtomicLong 生成算法介绍

## 1. 概述
RAtomicLong 是基于Java `AtomicLong` 的**单节点递增ID生成方案**，通过原子操作保证多线程环境下的ID唯一性和递增性。适用于单机高并发场景（如本地缓存键、临时任务ID），具有实现简单、性能高效的特点。

## 2. 核心特性
| 特性                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| 原子性保证          | 基于`AtomicLong`的CAS操作，确保多线程下无重复ID                       |
| 严格递增性          | 生成ID按调用顺序单调递增（步长可配置，默认+1）                        |
| 轻量高效            | 纯内存操作无IO开销，单线程可达百万次/秒，多线程无锁竞争               |
| 状态可持久化        | 支持将当前值写入磁盘/数据库，重启后可从断点继续生成（需额外实现）      |
| 数值范围限制        | 受限于Long类型（-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807）| 

## 3. 实现原理
RAtomicLong 核心依赖Java `AtomicLong` 类，通过`getAndIncrement()`方法实现原子递增。关键代码示例：

```java
import java.util.concurrent.atomic.AtomicLong;

public class RAtomicLongGenerator {
    private final AtomicLong counter = new AtomicLong(0);

    public long nextId() {
        return counter.getAndIncrement();
    }
}
```

### 扩展实现
- **步长控制**：通过`addAndGet(step)`支持自定义步长（如每次+10）
- **前缀拼接**：生成`业务类型_递增数值`格式（如`order_1001`）
- **范围保护**：设置最大值阈值（如`Long.MAX_VALUE - 1000`），触发时抛异常或重置

## 4. 与其他单机ID方案对比
| 特性                | RAtomicLong          | 自增数据库ID         | UUIDv4               |
|---------------------|----------------------|----------------------|-----------------------|
| 生成效率            | ✅ 百万次/秒          | ❌ 受数据库IO限制     | ✅ 高（随机数生成）     |
| 递增性              | ✅ 严格递增           | ✅ 数据库自增         | ❌ 无序                |
| 持久化支持          | ✅ 需手动实现         | ✅ 数据库自动持久化    | ❌ 无持久化需求         |
| 多线程安全          | ✅ 原子操作保证       | ✅ 数据库事务保证      | ✅ 无竞争              |
| 典型场景            | 本地缓存键、临时ID   | 数据库主键           | 全局唯一无排序需求     |

## 5. 使用注意事项
- **单机限制**：仅适用于单节点场景，分布式环境需结合分布式锁/Redis实现
- **数值溢出**：长时间运行可能达到`Long.MAX_VALUE`（约292年按1次/ms计算），需提前规划重置策略
- **重启断点**：未持久化时重启会从0开始，可能导致ID重复（需结合文件/数据库记录当前值）
- **性能瓶颈**：高并发下CAS操作可能产生重试（建议使用`LongAdder`替代提升吞吐量）
- **类型选择**：如需字符串ID，推荐拼接前缀（如`id_${nextId()}`）避免数值类型精度丢失