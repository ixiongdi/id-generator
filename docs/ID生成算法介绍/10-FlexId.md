# FlexID 算法详解

## 概述

FlexID 是一种为分布式环境设计的 ID 生成算法，旨在提供高性能、时间单调递增且对分库分表友好的唯一标识符。

## 特性

- **时间单调递增**：保证生成的 ID 按时间顺序递增，便于排序和查询。
- **高并发支持**：单机支持每秒 10 万级别的 ID 生成。
- **分布式友好**：最大支持 99 台机器集群部署，无需中心化协调。
- **时钟回拨处理**：运行时能够自动处理时钟回拨问题，保证 ID 的单调性（但在服务重启且时钟回拨的情况下可能存在重复风险）。
- **分库分表友好**：ID 末尾包含随机数，有助于数据在分片间的均衡分布。
- **使用寿命长**：基于 2024 年的基准时间戳，理论上可使用约 300 年。

## ID 结构

FlexID 由以下四个部分组成，各部分通过拼接形成最终的字符串 ID：

```
时间戳差值（7+位）| 序列号（2位：00-99）| 机器ID（2位：00-99）| 随机数（2位：00-99）
```

具体说明如下：

- **时间戳差值**：当前时间的毫秒数与一个预设的基准时间（例如：2024-04-02 00:00:00.000）的差值。这部分长度不固定，会随着时间的推移而增长。
- **序列号**：表示在同一毫秒内生成的 ID 的顺序号。其取值范围是 00 到 99，意味着同一毫秒内最多可以生成 100 个不同的 ID。
- **机器 ID**：用于标识生成 ID 的机器。其取值范围是 00 到 99，因此最多支持 100 台机器的集群。
- **随机数**：一个两位数的随机数，取值范围是 00 到 99。主要目的是为了在分库分表场景下，使数据分布更均匀。

## 实现原理简述

FlexID 的生成逻辑大致如下：

1. 获取当前时间的毫秒数，并计算与基准时间的差值。
2. 在同一毫秒内，通过一个原子计数器生成序列号。如果序列号达到上限（99），则等待下一毫秒。
3. 拼接时间戳差值、序列号、预设的机器 ID 以及一个随机生成的两位数，构成最终的 ID 字符串。
4. 算法内部会处理时钟回拨的情况，确保 ID 的趋势递增。通常做法是如果检测到时钟回拨，则继续使用上一次生成 ID 时的时间戳，或者在一定容忍范围内拒绝生成 ID，直到时钟追赶上来。

## 优点

- **高性能**：纯本地运算，无需网络 IO，生成速度快。
- **趋势递增**：ID 整体上是按时间增长的，利于数据库索引和排序。
- **易于理解和实现**：算法结构相对简单。
- **配置灵活**：机器 ID 可以手动配置。

## 缺点与使用限制

- **ID 长度不固定**：由于时间戳差值部分会增长，ID 的总长度不是固定的。
- **时钟回拨风险**：虽然运行时能处理时钟回拨，但在服务重启且发生时钟回拨的极端情况下，仍有极小概率产生重复 ID。
- **机器 ID 依赖手动配置**：需要为每台机器分配唯一的 ID（0-99），并确保配置正确。
- **单机 QPS 上限**：每台机器每秒最多生成 10 万个 ID（100 个序列号 \* 1000 毫秒/秒）。

## 使用注意事项

- **基准时间选择**：基准时间一旦确定，不应随意更改，否则会导致已生成的 ID 与新生成 ID 的比较和排序出现问题。
- **机器 ID 管理**：在分布式部署时，必须确保每台机器的 ID 唯一且在 0-99 范围内。
- **时钟同步**：尽管算法能处理一定程度的时钟回拨，但仍建议部署 NTP 服务，保证服务器时间的准确性，以降低风险。
- **监控**：对 ID 生成服务的 QPS 和错误情况进行监控，确保其正常运行。
